/**
 * Profile Editing Integration Tests
 * Tests profile field updates, validation, and persistence
 */

import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { IonicModule, ToastController } from '@ionic/angular';
import { RouterTestingModule } from '@angular/router/testing';
import { TranslateModule } from '@ngx-translate/core';
import { BehaviorSubject, of, throwError } from 'rxjs';
import { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';

import { SettingsPage } from '../../../settings/settings.page';
import { ProfileService } from '../../../core/services/profile.service';
import { LocalAuthService } from '../../../core/services/local-auth.service';
import { ThemeService } from '../../../core/services/theme.service';
import { DemoDataService } from '../../../core/services/demo-data.service';
import { UserProfile } from '../../../core/models/user-profile.model';

import {
  clickElement,
  queryIonicComponent,
  setInputValue,
  createMockToastController,
} from '../../helpers/dom-utils';

describe('Profile Editing Integration', () => {
  let component: SettingsPage;
  let fixture: ComponentFixture<SettingsPage>;
  let compiled: HTMLElement;

  let profileService: jasmine.SpyObj<ProfileService>;
  let authService: jasmine.SpyObj<LocalAuthService>;
  let themeService: jasmine.SpyObj<ThemeService>;
  let demoDataService: jasmine.SpyObj<DemoDataService>;
  let toastController: any;

  let profileSubject: BehaviorSubject<UserProfile>;

  const mockProfile: UserProfile = {
    id: '1000',
    name: 'Test User',
    age: 10,
    accountState: 'active' as any,
    dateOfBirth: '2014-01-01',
    tidepoolConnection: {
      connected: false,
    },
    preferences: {
      glucoseUnit: 'mg/dL',
      colorPalette: 'default',
      themeMode: 'auto',
      highContrastMode: false,
      targetRange: {
        min: 70,
        max: 180,
        unit: 'mg/dL',
      },
      notificationsEnabled: true,
      soundEnabled: true,
      showTrendArrows: true,
      autoSync: true,
      syncInterval: 15,
      language: 'es',
      dateFormat: '24h',
    },
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  beforeEach(async () => {
    // Create observable subjects
    profileSubject = new BehaviorSubject<UserProfile>(mockProfile);

    // Create service spies
    profileService = jasmine.createSpyObj(
      'ProfileService',
      ['getProfile', 'updateProfile', 'updatePreferences'],
      { profile$: profileSubject.asObservable() }
    );

    authService = jasmine.createSpyObj('LocalAuthService', [
      'isAuthenticated',
      'getCurrentUser',
    ]);

    themeService = jasmine.createSpyObj('ThemeService', [
      'getCurrentThemeMode',
      'setThemeMode',
    ]);

    demoDataService = jasmine.createSpyObj('DemoDataService', ['isDemoMode']);

    toastController = createMockToastController();

    // Setup default return values
    profileService.getProfile.and.returnValue(Promise.resolve(mockProfile));
    profileService.updateProfile.and.returnValue(Promise.resolve(mockProfile));
    profileService.updatePreferences.and.returnValue(Promise.resolve(mockProfile));

    authService.isAuthenticated.and.returnValue(of(true));
    authService.getCurrentUser.and.returnValue({
      dni: '1000',
      name: 'Test User',
      email: 'test@example.com',
    } as any);

    themeService.getCurrentThemeMode.and.returnValue('auto');
    demoDataService.isDemoMode.and.returnValue(true);

    await TestBed.configureTestingModule({
      imports: [
        IonicModule.forRoot(),
        RouterTestingModule,
        TranslateModule.forRoot(),
        SettingsPage,
      ],
      providers: [
        { provide: ProfileService, useValue: profileService },
        { provide: LocalAuthService, useValue: authService },
        { provide: ThemeService, useValue: themeService },
        { provide: DemoDataService, useValue: demoDataService },
        { provide: ToastController, useValue: toastController },
      ],
      schemas: [CUSTOM_ELEMENTS_SCHEMA],
    }).compileComponents();

    fixture = TestBed.createComponent(SettingsPage);
    component = fixture.componentInstance;
    compiled = fixture.nativeElement;
    fixture.detectChanges();
  });

  it('should create settings page for profile editing', () => {
    expect(component).toBeTruthy();
  });

  it('should load user profile data on init', fakeAsync(() => {
    component.ngOnInit();
    tick();
    fixture.detectChanges();

    // Component has user property from LocalAuthService
    expect(component.user).toBeTruthy();
  }));

  it('should edit and save profile name', fakeAsync(() => {
    const newName = 'Updated Name';

    // Update name
    component.profileSettings.name = newName;
    component.hasChanges = true;
    tick();
    fixture.detectChanges();

    // Verify changes flag is set
    expect(component.hasChanges).toBe(true);
  }));

  it('should update glucose unit preference', fakeAsync(() => {
    // Change from mg/dL to mmol/L
    component.glucoseSettings.unit = 'mmol/L';
    component.hasChanges = true;
    tick();
    fixture.detectChanges();

    expect(component.glucoseSettings.unit).toBe('mmol/L');
    expect(component.hasChanges).toBe(true);
  }));

  it('should update target range values', fakeAsync(() => {
    // Update target range
    component.glucoseSettings.targetLow = 80;
    component.glucoseSettings.targetHigh = 200;
    component.hasChanges = true;
    tick();
    fixture.detectChanges();

    expect(component.glucoseSettings.targetLow).toBe(80);
    expect(component.glucoseSettings.targetHigh).toBe(200);
  }));

  it('should save all settings when save is called', fakeAsync(() => {
    // Make changes
    component.profileSettings.name = 'New Name';
    component.glucoseSettings.unit = 'mmol/L';
    component.hasChanges = true;

    // Save settings
    component.saveSettings();
    tick();
    fixture.detectChanges();

    // Verify preferences update was called
    expect(profileService.updatePreferences).toHaveBeenCalled();
  }));

  it('should show success toast after successful save', fakeAsync(() => {
    component.hasChanges = true;

    // Save settings
    component.saveSettings();
    tick();
    fixture.detectChanges();

    // Verify toast was created
    expect(toastController.create).toHaveBeenCalled();
  }));

  it('should handle save error gracefully', fakeAsync(() => {
    // Mock error response
    profileService.updatePreferences.and.returnValue(
      Promise.reject(new Error('Save failed'))
    );

    component.hasChanges = true;

    // Attempt to save
    component.saveSettings();
    tick();
    fixture.detectChanges();

    // Verify error was handled (toast shown)
    expect(toastController.create).toHaveBeenCalled();
  }));

  it('should track unsaved changes', fakeAsync(() => {
    expect(component.hasChanges).toBe(false);

    // Make a change
    component.profileSettings.name = 'Changed Name';
    component.hasChanges = true;
    tick();

    expect(component.hasChanges).toBe(true);
  }));

  it('should update notification settings', fakeAsync(() => {
    const initialValue = component.notificationSettings.appointments;

    // Toggle appointment notifications
    component.notificationSettings.appointments = !initialValue;
    component.hasChanges = true;
    tick();
    fixture.detectChanges();

    expect(component.notificationSettings.appointments).toBe(!initialValue);
    expect(component.hasChanges).toBe(true);
  }));

  it('should add reading reminder time', fakeAsync(() => {
    const initialCount = component.notificationSettings.readingTimes.length;
    const newTime = '15:00';

    // Add new reminder time if not already present
    if (!component.notificationSettings.readingTimes.includes(newTime)) {
      component.notificationSettings.readingTimes.push(newTime);
      component.notificationSettings.readingTimes.sort();
      component.hasChanges = true;
    }
    tick();
    fixture.detectChanges();

    expect(component.notificationSettings.readingTimes).toContain(newTime);
  }));

  it('should remove reading reminder time', fakeAsync(() => {
    const timeToRemove = component.notificationSettings.readingTimes[0];

    // Remove reminder time
    component.notificationSettings.readingTimes =
      component.notificationSettings.readingTimes.filter(
        time => time !== timeToRemove
      );
    component.hasChanges = true;
    tick();
    fixture.detectChanges();

    expect(component.notificationSettings.readingTimes).not.toContain(
      timeToRemove
    );
  }));

  it('should update privacy settings', fakeAsync(() => {
    // Toggle data sharing
    component.privacySettings.shareDataWithDoctor = false;
    component.hasChanges = true;
    tick();
    fixture.detectChanges();

    expect(component.privacySettings.shareDataWithDoctor).toBe(false);
  }));

  it('should update sync settings', fakeAsync(() => {
    // Toggle auto sync
    component.syncSettings.autoSync = false;
    component.hasChanges = true;
    tick();
    fixture.detectChanges();

    expect(component.syncSettings.autoSync).toBe(false);
  }));

  it('should validate target range (low < high)', fakeAsync(() => {
    component.glucoseSettings.targetLow = 80;
    component.glucoseSettings.targetHigh = 200;

    expect(component.glucoseSettings.targetLow).toBeLessThan(
      component.glucoseSettings.targetHigh
    );
  }));

  it('should handle profile data from observable', fakeAsync(() => {
    const updatedProfile = { ...mockProfile, name: 'Updated Via Observable' };

    // Emit new profile data
    profileSubject.next(updatedProfile);
    tick();
    fixture.detectChanges();

    // Component should react to profile changes
    // (Actual behavior depends on component implementation)
  }));

  it('should maintain demo mode status', fakeAsync(() => {
    component.ngOnInit();
    tick();

    expect(component.isDemoMode).toBe(true);
  }));

  it('should reset hasChanges flag after successful save', fakeAsync(() => {
    component.hasChanges = true;

    // Save settings
    component.saveSettings();
    tick();
    fixture.detectChanges();

    // After successful save, hasChanges should be false
    expect(component.hasChanges).toBe(false);
  }));
});
